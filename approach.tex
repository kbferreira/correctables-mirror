
\section{Experiential Approach}
\label{sec:approach}

\subsection{APEI Error Injection}

As stated previously, this work is focused on the impacts of correctable errors.
These impacts occur at a number of different levels in the system.  To measure
these impacts we need a method of injecting these errors in a system to measure
the costs.  A number of methods exist to inject these types of errors on a
running system: from hardware-specific DRAM daughter cards that synthetically
flip memory cells within the DIMM device to methods that stress the memory
system in an effort to induce failures. 

In this work, we use the error injection table (EINJ) support provided as part
of the Advanced Configuration and Power Interface (ACPI)
specification~\cite{ACPISpec}.  EINJ provides a platform-independent interface
through which the platform OS can inject hardware errors to the platform without
requiring platform specific level software support. The primary goal of this
mechanism is to support testing of the OS error handling stack. Through this
capability the OS is able to implement a simple interface for diagnostic and
validation of RAS handling on the system.  EINJ is not supported on 
every production platform, it requires support from the host processor, OS, and
firmware/BIOS.

\begin{table}
\centering
\begin{tabular}{ c l }
\toprule
Error Type Value & Error Description \\
\midrule
 0x00000001 & Processor Correctable\\
 0x00000002 & Processor Uncorrectable non-fatal \\
 0x00000004 & Processor Uncorrectable fatal \\
 0x00000008 & Memory Correctable \\
 0x00000010 & Memory Uncorrectable non-fatal \\
 0x00000020 & Memory Uncorrectable fatal \\
 0x00000040 & PCI Express Correctable \\
 0x00000080 & PCI Express Uncorrectable fatal \\
 0x00000100 & PCI Express Uncorrectable non-fatal \\
 0x00000200 & Platform Correctable \\
 0x00000400 & Platform Uncorrectable non-fatal \\
 0x00000800 & Platform Uncorrectable fatal \\
\bottomrule
\end{tabular}
\vspace{.6em}
\caption{
        Available error types defined in ACPI specification 
}
\label{tab:einj}
\end{table}

The specification defines a number of different error types.  These types are
defined in \Cref{tab:einj}.  On our test linux platform, only the memory
correctable and memory uncorrectable error types are supported.  Injecting
errors through the EINJ table on linux is done through the sysfs filesystem
interface.  This injection interface allows a user to specifically the error type
and memory address for the error.

\subsection{Simulating Correctable Overheads}

In general, the communication structure of Message Passing Interface (MPI)
programs cannot be determined offline because message matches cannot be
established statically~\cite{bronevetsky2009communication}.  This makes
modeling application performance analytically challenging even if all
parameters of the application (e.g., the complete communication structure and
all relative inter-process timings) are known.  We therefore use a validated
discrete-event simulation framework to evaluate the impact of local
correctable error mitigation activities on the performance of real applications.
%for real applications via their message traces.

Our simulation-based approach models correctable error mitigation activities as CPU detours: periods
of time during which the CPU is taken from the application and used to compute and commit
checkpoint data.  This approach allows a level of
fidelity and control not always possible in implementation-based approaches. It
also allows us to examine simulated systems much larger than those generally available.

Our simulation framework is based on the freely available
\LogGOPSim~\cite{Hoefler:2010:LogGOPSim} and the tool chain provided  by Levy et
al.~\cite{Levy2013UsingSimulation}.  \LogGOPSim uses the LogGOPS model, an
extension of the well-known LogP model~\cite{Culler:1993:LogP}, to account for
the temporal cost of communication events.  An application's communication
events are generated from traces of the application's execution.  These traces
contain the sequence of MPI operations invoked by each application process.
\LogGOPSim uses these traces to reproduce all communication dependencies,
including indirect dependencies between processes which do not communicate
directly.

\LogGOPSim can also extrapolate traces from small application runs; a trace
collected by running the application with $p$ processes can be extrapolated to
simulate performance of the application running with $k\cdot p$ processes. The
extrapolation produces exact communication patterns for MPI collective
operations and approximates point-to-point
communications~\cite{Hoefler:2010:LogGOPSim}.  The validation of \LogGOPSim and
its trace extrapolation features have been documented
previously~\cite{Hoefler:2010:LogGOPSim}, along with the simulators ability to
accurately predict application performance in the presence of performance
perturbations~\cite{Ferreira:2014:Understanding,Levy2013UsingSimulation,Hoefler:2010:Characterizing}

\subsection{Simulating Applications with Correctable Errors}

\kbf{Add application workloads}


\clearpage
\appendix
\section{Artifact Description: \kbf{add title}}
\label{sec:appendix}


\kbf{This is incorrect, a completely new folktale needs to be written}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Abstract}

This artifact contains instructions on accessing the \LogGOPSim simulator and
the application execution traces that were used for the correctable DRAM error 
logging overhead experiments in \refsec{sec:results:correctable_dram_perf}. 
It also contains instructions on obtaining and using the failure log analysis
scripts used throughout \refsec{sec:results}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Description}

\subsubsection{Check-list (artifact meta information)}

{\small
\begin{itemize}
  \item {\bf Program}: C++ for \LogGOPSim, Python for log analysis
  \item {\bf Compilation}: g++ 4.2+ for \LogGOPSim, Python 2.7+
  \item {\bf Data set}: In this paper, we analyzed a corpus of failure data collected over
  the five-year lifetime of \cielo.  This corpus of data consists primarily of the contents
  of system logs.  A detailed description of the contents of these logs and the relevant 
  data that each contains is presented in \refsec{sec:method:system_logs} in the body of the paper.

  We also used a collection of application execution traces in our correctable DRAM error 
  experiments.  The applications used were: LAMMPS-lj, LAMMPS-crack, LAMMPS-SNAP,
  LULESH, miniFE, GTC-p, and CTH.  In addition, we also used execution traces for three 
  microbenchmarks: allreduce, reduce, and stencil.
  \item {\bf Run-time environment}: MacOS 10.8+ or any modern Linux distribution
  \item {\bf Hardware}: Any
  \item {\bf Experiment customization}: modify Makefile to specify different application
  traces or reliability logs
  \item {\bf Publicly available?}: All but one of the execution traces (CTH) is publicly 
  available.  Because CTH is an export-controlled application, its traces cannot be 
  released publicly.  

  System logs collected on \cielo contain significant proprietary information that is 
  covered by one or more non-disclosure agreements~(NDA).  As a result, we cannot publicly
  release this corpus of data.  Our repository contains a sample of random data that can
  be used to demonstrate the operation of our analysis scripts.
\end{itemize}
}

\subsubsection{How software can be obtained (if available)}
\begin{itemize}
\item \LogGOPSim is available at:\\
    \url{https://htor.inf.ethz.ch/research/LogGOPSim/LogGOPSim-1.1.tgz}.  

\item Failure log analysis scripts can be found in our repository at: 
    \detail{made up repo}
\end{itemize}

\subsubsection{Hardware dependencies}

\LogGOPSim will run on any modern general-purpose computer. However, the
largest application scale and duration that can be simulated depends on
available RAM.  Memory usage increases linearly in both and scale and application
runtime.

\subsubsection{Software dependencies}

Application simulations were run on a supercomputer running Linux located at
\detail{Sandia National Laboratories}.  Both \LogGOPSim and the log
analysis scripts have been tested on Linux and MacOS running Python 2.7,
Matplotlib 2.0.0, and g++ 4.2.1

\subsubsection{Datasets}

\begin{table}
\centering
\begin{tabular}{ l c }
\toprule
LogGOPS parameter & Value\\
\midrule
\textcolor{red}{L}atency                & 1.8$\mu s$ \\
\textcolor{red}{o}verhead per message   & 12.4$\mu s$ \\
\textcolor{red}{g}ap per message        & 2.6$\mu s$  \\
\textcolor{red}{G}ap per byte           & 1$ns$     \\
\textcolor{red}{O}verhead per byte      & 0$ns$     \\
\textcolor{red}{S}: rendezvous threshold  & 65,536 bytes \\
\bottomrule
\end{tabular}
\caption{
  LogGOPS parameters used in our study. Values measured using~\cite{netgauge-web}
}
\label{tab:logp}
\end{table}

Application traces used (excluding CTH) are located in the {\texttt{traces}} 
directory of our repository.  LogP parameters used are specified in \reftab{tab:logp}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Installation}

Installation instructions are available at: \url{https://htor.inf.ethz.ch/research/LogGOPSim/}

Log analysis install instructions:

{\texttt{\$ git clone \detail{A very fake repo}}}

\subsubsection{APEI Error INJection Installation (EINJ)}

The {\texttt{configure\_apei.sh}} script checks and properly installs system
software for error injection.  If script fails on any test, injection support is
not supported on architecture.  Script should be run on a Linux system, and with
{\texttt{root}} privileges.

\begin{Verbatim}[commandchars=\\\{\},frame=single]
 $ sudo configure_apei.sh
Checking kernel version: 3.10.0-229 \color{green}{PASS}
Checking kernel commandline:        \color{green}{PASS}
Checking for ACPI EINJ table: found \color{green}{PASS}
Checking for kernel modules:
 ... loading einj module            \color{green}{PASS}
Checking supported APEI error injection
types:
 0x00000008 Memory Correctable
 0x00000010 Memory Uncorrectable
non-fatal
 0x00000020 Memory Uncorrectable fatal
 0x00000040 PCI Express Correctable
 0x00000080 PCI Express Uncorrectable
non-fatal
 0x00000100 PCI Express Uncorrectable
fatal
                                    \color{green}{PASS}
Test Complete: \color{green}{PASS}
\end{Verbatim}


\subsubsection{Error Injection Utility}

If the {\texttt{configure\_apei.sh}} script from the previous sections completes
without error, error injection is possible on the platform.  The
{\texttt{error\_inject.py}} script included in the repo can be used to to inject
correctable (and detected, non -fatal uncorrectables as well).  Passing {\texttt{--help}}
to the script provides a descrition of the options (must be run as
{\texttt{root}} as well)

\begin{Verbatim}[commandchars=\\\{\},frame=single]
 $ ./error_inject.py --help
usage: error_inject.py [-h] [-i INTERVAL]
[-l LENGTH] [-c | -u] [-d] [-v]
[-a ADDR [ADDR ...]]

APEI error injection utility

optional arguments:
  -h, --help show this help
message and exit
  -i INTERVAL, --interval INTERVAL
Periodic interval in seconds to inject
memory errors
  -l LENGTH, --length LENGTH Length
in seconds to run application (default
1200 secs)
  -c, --dram-correctable Inject
DRAM correctable error (default on)
  -u, --dram-uncorrectable Inject
DRAM uncorrectable error non-fatal
(default off)
  -d, --dry-run         Dry-run,
do not actually inject the error
(default off)
  -v, --version         show
program's version number and exit
  -a ADDR [ADDR ...],
  --addr ADDR [ADDR ...] List
of address to inject into
(default 0x12345000)
 
\end{Verbatim}

As an example, if we want to inject correctable memory errors at an interval of
every 100 seconds, at addresses {\texttt{0x12345000}}, {\texttt{0x12346000}} and
{\texttt{0x123457000}} for 1400 seconds.

\begin{Verbatim}[commandchars=\\\{\},frame=single]
 $ sudo ./error_inject.py -i 100 -l 1400
-c -a 0x12345000 0x12346000 0x123457000
\end{Verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Experiment workflow}

{\texttt{\$ make DRAM-overheads \# For \LogGOPSim runs and correctable DRAM plots}}

{\texttt{\$ make analysis \# For log analysis plots}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Evaluation and expected result}

All generated figures will be placed in the {\texttt{figs}} directory

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Experiment customization}

New application traces can be added for analysis by adding the new trace
directory to the {\texttt{TRACES}} variable in the top-level Makefile

New reliability logs can be added by modifying the {\texttt{LOG\_LOCATION}}
variable in that same Makefile

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Notes}

Using \LogGOPSim to simulate the execution of an application running on 
a large number of nodes can be very time-consuming.  In extreme cases,
it may take a day or more to simulate a few minutes of execution of
very large applications.
